#version 330

struct lightInfo 
{
	vec4 direction;
	vec3 position;
	vec3 color;
	int  type;
	float linearAtt;

};

uniform sampler2D colorText;
uniform lightInfo lights[8];
uniform int numLights;
uniform vec3 ambient;

uniform int texturing;
uniform int lighting;
uniform int normalMode;

uniform int shininess;
uniform vec3 eyePos;
uniform vec4 baseColor;

in vec2 ftextcoord;
in vec4 fpos;
in vec4 fnormal;
out vec4 fragColor;

void main()
{
	// Diferentes combinaciones
	// Iluminado + no text		 -> colorIluminacion * colorBase
	// Iluminado + text			 -> colorIluminacion * colorText
	// No iluminado + text		 -> colorText
	// No iluminado + no text	 -> colorBase

	vec4 objectColor;

	if (texturing == 1)
	{
		fragColor = texture2D(colorText,ftextcoord);
		objectColor = fragColor; // Si el objeto esta texturizado se sustituye el colorBase con el color de la textura
	}	
	else
	{
		fragColor = baseColor;
		objectColor = baseColor;
	}

	if (lighting == 1)
	{
		vec3 N;

		if(normalMode == 1)		// PER_VERTEX
		{
			N = normalize(fnormal.xyz);
		}
		else if (normalMode == 2)	// FROM_MAP
		{
			// coger normal del mapa de normales
		}

		float diff = 0.0f;
		float spec = 0.0f;	
		vec3 lightColor = vec3(1.0f, 1.0f, 1.0f);

		for (int i  = 0; i < numLights; i++)
		{
			vec3 L=vec3(0.0f,0.0f,0.0f);
			float distance = 0;

			if(lights[i].type == 0)
			{
				L = normalize(lights[i].direction.xyz);
			}
			else if(lights[i].type == 1)
			{
				L = lights[i].position - fpos.xyz;
				distance = length(L);
				L = normalize(L);
			}

			vec3 R = normalize(reflect(L,N));
			vec3 EYE = normalize(fpos.xyz-eyePos);
			float attenuation = 1.0f / (1.0f + lights[i].linearAtt * distance); 

			// Factor de intensidad por defecto 0.5
			diff += 0.5f * attenuation * max( dot(L,N),0.0f);
			spec += 0.5f * attenuation * pow(max(dot(R,EYE),0.0f),shininess);

			lightColor *= lights[i].color;
		}

		vec3 diffuse = diff * lightColor;
		vec3 specular = spec * vec3(1.0f);

		fragColor = vec4(ambient + diffuse + specular, 1.0) * objectColor;
	}
}

