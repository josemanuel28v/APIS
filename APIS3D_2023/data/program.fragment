#version 330
#extension GL_NV_shadow_samplers_cube : enable

struct lightInfo 
{
	vec4 direction;
	vec3 position;
	vec3 color;
	int  type;
	float linearAtt;

};

uniform int textType; //
uniform samplerCube cubeText; //
uniform sampler2D normalText; 
uniform sampler2D colorText;
uniform lightInfo lights[8];
uniform int numLights;
uniform vec3 ambient;

uniform int texturing;
uniform int lighting;
uniform int normalMode;

uniform int shininess;
uniform vec3 eyePos;
uniform vec4 baseColor;

in vec2 ftextcoord;
in vec4 fpos;
in vec4 fnormal;
in vec3 ftextCube; //
in mat3 TBN; 

out vec4 fragColor;

void main()
{
	// Diferentes combinaciones
	// Iluminado + no text		 -> colorIluminacion * colorBase
	// Iluminado + text			 -> colorIluminacion * colorBase * colorText
	// No iluminado + text		 -> colorBase * colorText
	// No iluminado + no text	 -> colorBase

	// De momento un objeto puede:
	//		Tener su propia textura 2D (objeto texturizado normal)
	//		Tener su propia textura 3D (objeto skybox)
	//		Tener un reflectCubeMap (objeto al que se le pega la reflexion del skybox)
	//		Tener un refractCubeMap (objeto al que se le pega la refracciion del skybox)

	vec4 objectColor = baseColor;

	if (texturing == 1)
	{
		if (textType == 0) // Color2D
		{
			objectColor = objectColor * texture2D(colorText, ftextcoord);
		}
		else if (textType == 1) // Color3D (skybox o objetos reflectantes o refractantes)
		{
			objectColor = objectColor * textureCube(cubeText, ftextCube);
		}
	}	

	if (lighting == 1)
	{
		vec3 N;

		if(normalMode == 1)		// PER_VERTEX
		{
			N = normalize(fnormal.xyz);
		}
		else if (normalMode == 2)	// FROM_MAP
		{
			vec3 normalTextValue = texture2D(normalText, ftextcoord).xyz;
			normalTextValue = normalTextValue * 2.0f - 1.0f;
			N = normalize(TBN * normalTextValue);
		}

		float diff = 0.0f;
		float spec = 0.0f;	
		vec3 lightColor = vec3(1.0f, 1.0f, 1.0f);

		for (int i  = 0; i < numLights; i++)
		{
			vec3 L=vec3(0.0f,0.0f,0.0f);
			float distance = 0;

			if(lights[i].type == 0)
			{
				L = normalize(lights[i].direction.xyz);
			}
			else if(lights[i].type == 1)
			{
				L = lights[i].position - fpos.xyz;
				distance = length(L);
				L = normalize(L);
			}

			vec3 R = normalize(reflect(L,N));
			vec3 EYE = normalize(fpos.xyz-eyePos);
			float attenuation = 1.0f / (1.0f + lights[i].linearAtt * distance); 

			// Factor de intensidad por defecto 0.5
			diff += attenuation * max( dot(L,N),0.0f);
			spec += attenuation * pow(max(dot(R,EYE),0.0f),shininess);

			lightColor *= lights[i].color;
		}

		lightColor = normalize(lightColor);

		vec3 diffuse = diff * lightColor;
		vec3 specular = spec * vec3(1.0f);

		objectColor = vec4(ambient + diffuse + specular, 1.0) * objectColor;
	}

	fragColor = objectColor;
}

